#+TITLE: Bitcoin Wallet Cost Function Analysis
#+LATEX_HEADER: \usepackage{svg}

#+begin_abstract
This repository proposes a framework for studying cost functions for the
decision space available to Bitcoin wallets when creating transactions. A
primary goal is accounting for user defined liabilities incurred by transactions
lacking the desired level of privacy or confidentiality, and their interaction
with confirmation times. This is in addition to well established objective
metrics such as the blockspace or fees required for a transaction, which are
taken for granted.
#+end_abstract

* Preliminaries

** Transaction Structure

#+NAME: fig:basic_transactions
#+BEGIN_SRC dot :file diagrams/examples/basic_transactions.svg
strict digraph {
    graph [bgcolor=transparent color="#666666" labelloc=b nodesep=0.05 penwidth=0.5 rankdir=LR ranksep=0.02 style=rounded]
    node [color=transparent fillcolor="#ffffff" fontcolor="#000000" fontname=helvetica fontsize=11 height=0 margin=0.04 minsep=1 penwidth=2 sep=1 shape=box style="rounded,filled" width=0]
    edge [color="#909090" arrowsize=0.5 minlen=3 penwidth=1]

    // group together the coins of a single transact    io  n
    subgraph cluster_tx_1 {
        graph [bgcolor="#d0d0d0" margin=7 ranksep=0.02]
        edge [minlen=1]

        // group together the inputs
        subgraph cluster_tx_1_inputs {
            graph [margin=0 style=invis]
            input_1_1 [label=1.0]
            input_1_2 [label=0.5]
            input_1_3 [label=0.5]
        }

        // group together the outputs
        subgraph cluster_tx_1_outputs {
            graph [margin=0 style=invis]
            output_1_1 [label=1.1]
            output_1_2 [label=0.7999]
            output_1_3 [label=0.1]
        }

        // add an invisible edge from one of the inputs to one of the outputs,
        // causing them to be laid out in two columns
        input_1_1 -> output_1_1 [constraint=true len=0.01 style=invis]
    }

    subgraph cluster_tx_2 {
        graph [bgcolor="#d0d0d0" margin=7 ranksep=0.02]
        edge [minlen=1]
        subgraph cluster_tx_2_inputs {
            graph [margin=0 style=invis]
            input_2_1 [label=1.1]
            input_2_2 [label=0.7999]
        }
        subgraph cluster_tx_2_outputs {
            graph [margin=0 style=invis]
            output_2_1 [label=1.0]
            output_2_2 [label=0.8998]
        }
        input_2_1 -> output_2_1 [constraint=true len=0.01 style=invis]
    }

    // Connect outputs to the inputs that spend them
    output_1_1 -> input_2_1
    output_1_2 -> input_2_2

    // Mark unspent coins, normally the border color is transparent
    output_1_3 [color="#333333"]
    output_2_1 [color="#333333"]
    output_2_2 [color="#333333"]
}
#+END_SRC

#+CAPTION: A simplified illustration of two (somewhat contrived) transactions illustrated using Graphviz. Within each transaction coins appear as inputs on the left column and as outputs on the right, represented by their nominal values. The same coin may appear twice when has been spent, in which case an arrow connects from the output that created it to the input that spent it. A heavy border highlights unspent outputs. The previous outputs of the first transaction are not displayed.
#+RESULTS: fig:basic_transactions
[[file:diagrams/examples/basic_transactions.svg]]

As a first approximation, Bitcoin transactions consist of two lists, one of
/inputs/ and one of /outputs/. Inputs fund a transaction, spending the outputs
of prior transactions by reference, accompanied with proof that the transaction
is authorized. The number of sats allocated to each output is specified in its
value. Transactions which are not fully funded aren't valid. Transaction are
identified by their /txid/, derived by hashing them. Inputs refer to previous
outputs by using a ~txid~ and an index specifying the output being spent.

The transaction graph is the overall structure formed by transactions being
interconnected. Because the full graph is publicly known, every coin has a
history comprising of its funding transaction. That transaction is of course
funded by other coins, the transactions that created them were in turn funded by
others still, and so on. Similarly, one can talk about all of the transactions
that follow a certain coin or a certain transaction, to some depth.

Transaction fees are paid by making the sum of the output values in a
transaction smaller than the implied sum of the input values (this is calculated
from values of the /previous outputs/). Although no fees are required for a
transaction to be valid nodes can specify a minimum feerate for transactions
relayed to them in order to avoid clogging their mempools.[fn::Blocks may
include any valid transaction, but relayed transactions generally must also
conform to standardness rules which introduce some additional constraints.]

In addition to what was already mentioned, the data of a transaction consists of
output scripts, and signature or witness data[fn::Witness data is not included
in the ~txid~ hash, as indicated by the name Segregated Witness. This allows
transactions that *only* contain SegWit inputs to have a known ~txid~ before
they are signed. Knowing the ~txid~ in advance makes it possible to prepare and
sign dependent transactions ahead of time, before authorizing a whole set of
possible outcomes with the final signature on the initial transaction.] which
proves authorization for each input, a version field and a locktime field. The
space requirement for this data is accounted for using /weight units/. This can
divide the total fees paid by a transaction to calculate a feerate in sats per
weight unit, but more commonly fees are given in sats per (kilo) /virtual
byte/.[fn::Virtual bytes can be thought of as \(\lfloor\frac{\textrm{weight
units} + 3}{4}\rfloor\), where literal bytes of data are counted as either 1 or
4 weight units depending on what they represent, witness data only counts as 1
and is therefore effectively discounted.]

Before a transaction is fully constructed its feerate is generally not known
even if its input and output lists are finalized because the final weight of
non-taproot inputs will vary. The actual sizes are typically within a few weight
units of the worst case values. Accounting for the worst case a minimum feerate
can be guaranteed, with the effective feerate for the input typically
overshooting it by a negligible amount. The shared overhead (up to a few dozen
weight units) in a transaction must also be taken into account in order to
ensure a minimum feerate for the transaction as a whole.

The effective value of inputs and effective cost of outputs can be defined as
the associated nominal values adjusted by some fee amount. For inputs the fees
are subtracted from the previous outputs' nominal values, and for outputs the
fee amount is added to the nominal value. For each input and output, given a
feerate[fn::Note that this feerate will not be the same as the transaction's
final feerate, because the overhead of the data shared by all inputs and outputs
must also be taken into account, and because some input types' weight is not
constant.], the adjustment can be derived from the weight, and given an
adjustment a feerate can be derived from the weight.

One definition of a /wallet/ that we will use is a collection of coins at a
point in time. Since a wallet belonging to a user will typically not have a coin
(or combination of coins) of exactly the right amount in order to make a
payment with an arbitrary amount, transactions often send some of the input
funds back to the owner of the transaction. These are known as /change/ outputs,
or more generally /self-spend/ outputs.
